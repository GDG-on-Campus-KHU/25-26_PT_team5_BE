[
  {
    "url":"https:\/\/yozm.wishket.com\/magazine\/detail\/3475\/",
    "title":"TanStack Query 너머를 향해: 쿼리를 라우트까지 전파시키기",
    "author":"FEConf",
    "posted_at":"1일 전",
    "category":"개발",
    "content":"RSC는 서버와 클라이언트의 역할을 다시 나눕니다 물론 클라이언트에서 값을 fetch하기 위해 기다리는 시간은 없을 겁니다. 하지만 Server Component가 중첩되면 중첩될수록 상위 컴포넌트에서 `await`이 끝나야만 하위 컴포넌트가 반환되고, 그게 계속 중첩되다 보면 직렬로 기다리면서 0.3초, 0.5초, 0.2초 기다린 동작이 다 합쳐져 1초가 걸리게 되는 딜레이 문제가 발생할 수도 있습니다. 첫 번째 전략은 0부터 현재의 위치까지, 그리고 나서 더 봐야 할 내용까지 전부 그려서 내려주는 겁니다. 서버 단에서 계산을 너무 많이 해야 하니까요. 하지만 이건 RSC에서 사용하는 방식을 잘 이해하지 않는다면 클라이언트 로직을 많이 짜야 하고, 그를 통해 클라이언트 로직 부담이 너무 심해질 수도 있습니다. 첫 번째 시도: 같은 파일에 두기\n\nIsograph의 강타입 prop을 사용하면서 동시에 Toss 구조처럼 아래에서 위로 올려주는 리소스를 만들어보자는 생각을 했습니다.",
    "thumbnail_url":"https:\/\/yozm.wishket.com\/media\/news\/3475\/adfef.png"
  }
]